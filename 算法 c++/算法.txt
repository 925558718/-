//前序遍历 迭代版
vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> s;
        TreeNode *p=root;
        while(p||!s.empty()){
            if(p){
                s.push(p);
                res.push_back(p->val);
                p=p->left;
            }else{
                TreeNode *t=s.top();s.pop();
                p=t->right;
            }
        }
        return res;
    }

//逆转链表
ListNode* reverseList(ListNode* head) {
        递归版
        //if(!head||!head->next) return head;
        //ListNode *newHead=reverseList(head->next);
        //head->next->next=head;
        //head->next=NULL;
        //return newHead;
        迭代班
        ListNode *newHead=NULL;
        while(head){
            ListNode *t=head->next;
            head->next=newHead;
            newHead=head;
            head=t;
        }
        return newHead;

    }


反转二叉树

//if(!root) return NULL ;
        //TreeNode *temp=root->left;
        //root->left=invertTree(root->right);
        //root->right=invertTree(temp);
        //return root;
        if(!root) return NULL;
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty()){
            TreeNode *node=q.front();q.pop();
            TreeNode *temp=node->left;
            node->left=node->right;
            node->right=temp;
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        return root;

//从尾到头反过来打印出每个结点的值。
//递归
//vector<int> printListFromTailToHead(ListNode* head) {
//	if (!head) return {};
//	vector<int> res;
//	printListFromTailToHead(head, res);
//	return res;
//}
//void printListFromTailToHead(ListNode* head, vector<int>& res) {
//	if (!head) return;
//	printListFromTailToHead(head->next, res);
//	res.push_back(head->val);
//}
//迭代 栈
//vector<int> printListFromTailToHead(ListNode* head) {
//	stack<int> s;
//	while (!head) {
//		s.push(head->val);
//		head = head->next;
//	}
//	vector<int> res;
//	while (!s.empty()) {
//		int num = s.top();
//		s.pop();
//		res.push_back(num);
//	}
//	return res;
//}


//根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
//TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
//	return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
//}
//TreeNode* buildTree(vector<int> & preorder, int pLeft, int pRight, vector<int> & inorder, int iLeft, int iRight) {
//	if (pLeft > pRight || iLeft > iRight) return NULL;
//	int i = 0;
//	for (i = iLeft; i <= iRight; ++i) {
//		if (preorder[pLeft] == inorder[i]) break;
//	}
//	TreeNode* cur = new TreeNode(preorder[pLeft]);
//	cur->left = buildTree(preorder, pLeft + 1, pLeft + i - iLeft, inorder, iLeft, i - 1);
//	cur->right = buildTree(preorder, pLeft + i - iLeft + 1, pRight, inorder, i + 1, iRight);
//	return cur;
//}

//用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。
//class stackQueue {
//private: stack<int> s1;
//private: stack<int> s2;
//
//public:void pushNum(int num) {
//	s1.push(num);
//}
//public:int getfront() {
//	while (!s1.empty())
//	{
//		s2.push(s1.top());
//		s1.pop();
//
//	}
//	return s2.top();
//}
//};

//选择排序

//void select(vector<int> &arr) {
//	for (size_t i = 0; i < arr.size()-1; i++)
//	{
//		int target = i;
//		for (int j = i+1; j < arr.size(); j++) {
//			if (arr[target]>arr[j])
//			{
//				target = j;
//			}
//		}
//		swap(arr[i], arr[target]);
//	}
//}
//冒泡
//void mopao(vector<int>& arr) {
//	for (int i = 0; i < arr.size()-1; i++)
//	{
//		for (int j = 0; j < arr.size() - 1; j++) {
//			if (arr[j]>arr[j+1])
//			{
//				swap(arr[j], arr[j+1]);
//			}
//		}
//	}
//}

//选择排序	×	N2	1
//冒泡排序	√	N2	1
//插入排序	√	N ~N2	1	时间复杂度和初始顺序有关
//希尔排序	×	N 的若干倍乘于递增序列的长度	1	改进版插入排序
//快速排序	×	NlogN	logN
//三向切分快速排序	×	N ~NlogN	logN	适用于有大量重复主键
//归并排序	√	NlogN	N
//堆排序	×	NlogN	1	无法利用局部性原理

void insertSort(vector<int> &arr) {

	for (int i = 1; i < arr.size(); i++)
	{
		for ( size_t j = i; j > 0; j -- )
		{

		}
	}
}
//在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。
int duplicate(vector<int> arr) {
	int length = arr.size();
	if (length==0)
	{
		return -1;
	}
	for (size_t i = 0; i < length; i++)
	{
		while (arr[i] != i) {
			if (arr[i] == arr[arr[i]]) {
				return arr[i];
			}
			swap(arr[i], arr[arr[i]]);
		}
	}
	return -1;
}

//给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中
bool findMatrix2D(vector<vector<int>> &arr,int target) {
	if (arr.empty() || arr[0].empty()) return false;
	int row = arr[0].size()-1;
	int column = arr.size()-1;
	int x = column, y = 0;
	while (x >= 0 && y<=row) {
		if (arr[x][y] = target) return true;
		if (arr[x][y] > target)
		{
			y++;
		}
		if (arr[x][y] < target)
		{
			x--;
		}
	}
	return true;
}

//将一个字符串中的空格替换成 "%20"。

string to20 (string &str) {
	int length1 = str.size()-1;
	for (auto i : str) {
		if (i==' ')
		{
			str.append("  ");
		}
	}
	int length2 = str.size()-1;
	while (length1>=0&&length2>length1)
	{
		char c = str[length1--];
		if (c==' ')
		{
			str[length2--] = '0';
			str[length2--] = '2';
			str[length2--] = '%';
		}
		else {
			str[length2--] = c;
		}
	}
	return str;
}

//链表有环
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        ListNode *fast=pHead;
        ListNode *slow=pHead;
        while(fast->next&&fast){

            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow){
                return fast;
            }
        }
        return NULL;
    }
